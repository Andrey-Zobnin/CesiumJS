<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cesium 3D Tiles Vector LOD MVP</title>
  <script src="https://cdn.jsdelivr.net/npm/cesium@latest/Build/Cesium/Cesium.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/cesium@latest/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html, body, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: monospace; }
    .counter { position: absolute; left: 10px; color: #fff; text-shadow: 0 0 4px #000; z-index: 1000; font-size: 14px; }
    #fpsCounter { top: 10px; }
    #vertexCounter { top: 30px; }
    #featureCounter { top: 50px; }
    #polylineCounter { top: 70px; }
    #terminalLog { position: absolute; left: 0; bottom: 0; width: 480px; max-width: 90vw; height: 180px; background: rgba(20,20,30,0.80); color: #0f0; font-family: monospace; font-size: 13px; border-radius: 8px 8px 0 0; box-shadow: 0 0 20px #0009; z-index: 1200; padding: 10px 8px 7px 12px; overflow-y: auto; }
    #terminalTitle { font-size: 13px; color: #fff6; margin-bottom: 4px; font-weight: bold; }
    .log-error { color: #f44; }
    .log-system { color: #9ff; }
    .log-debug { color: #aaa; }
    #lodSettings {
      position: absolute;
      top: 100px;
      left: 12px;
      color: #eee;
      font-size: 13px;
      background: rgba(30,30,40,0.9);
      padding: 8px 12px;
      border-radius: 6px;
      z-index: 1200;
      box-shadow: 0 0 8px #0008;
      min-width: 210px;
    }
    #lodSettings input[type="number"] { width: 60px; }
    #lodSettings label { font-weight: bold; }
    #autoBtn {
      margin-left: 10px;
      font-size: 12px;
      padding: 2px 10px;
      border-radius: 3px;
      border: 1px solid #444;
      background: #23232a;
      color: #fff;
      cursor: pointer;
    }
    #autoBtn.active {
      background: #08f;
      color: #fff;
      border: 1px solid #09f;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="fpsCounter" class="counter">FPS: <span id="fpsVal">-</span></div>
  <div id="vertexCounter" class="counter">Vertices: <span id="vertexVal">-</span></div>
  <div id="featureCounter" class="counter">Features: <span id="featureVal">-</span></div>
  <div id="polylineCounter" class="counter">Polylines: <span id="polylineVal">-</span></div>
  <div id="terminalLog"><div id="terminalTitle">[ ACTION LOG ]</div><div id="terminalOutput"></div></div>
  <div id="lodSettings">
    <label for="vertexFraction">Vertex percent:</label>
    <input type="number" min="0.01" max="1.0" step="0.01" value="1.00" id="vertexFraction" />
    <button id="autoBtn" type="button">Auto</button>
    <span id="vertexFractionVal" style="margin-left:10px;">1.00</span>
    <div style="margin-top:8px">
      <div>Camera height: <span id="cameraHeightVal">-</span> m</div>
    </div>
  </div>
  <script>
    // Output element for terminal log
    const terminalOutput = document.getElementById('terminalOutput');

    // Log a message to the terminal log
    function logAction(message, type="system") {
      const span = document.createElement('span');
      span.className = "log-" + type;
      span.textContent = `[${(new Date()).toLocaleTimeString()}] ` + message;
      terminalOutput.appendChild(span);
      terminalOutput.appendChild(document.createElement('br'));
      terminalOutput.scrollTop = terminalOutput.scrollHeight;
    }

    const cesiumViewer = new Cesium.Viewer('cesiumContainer');
    let tilesetInstance;
    const tileDataMap = new Map();
    const vertexCounterValue = document.getElementById('vertexVal');
    const featureCounterValue = document.getElementById('featureVal');
    const polylineCounterValue = document.getElementById('polylineVal');
    const fpsCounterValue = document.getElementById('fpsVal');
    let lastFpsUpdate = performance.now(), fpsCounter = 0;

    // Controls for vertex fraction
    const vertexFractionInput = document.getElementById('vertexFraction');
    const vertexFractionVal = document.getElementById('vertexFractionVal');
    const cameraHeightVal = document.getElementById('cameraHeightVal');
    const autoBtn = document.getElementById('autoBtn');
    let vertexFraction = parseFloat(vertexFractionInput.value);
    let autoMode = false;

    // Update display for vertex fraction value
    function updateVertexFractionDisplay() {
      vertexFractionVal.textContent = (+vertexFraction).toFixed(2);
      vertexFractionInput.value = (+vertexFraction).toFixed(2);
    }

    vertexFractionInput.addEventListener('input', function() {
      let val = parseFloat(this.value);
      if (isNaN(val)) val = 1.0;
      if (val < 0.01) val = 0.01;
      if (val > 1.0) val = 1.0;
      vertexFraction = val;
      autoMode = false;
      autoBtn.classList.remove('active');
      updateVertexFractionDisplay();
      tileDataMap.forEach(tileInfo => tileInfo._lastVertexFraction = undefined);
    });

    autoBtn.addEventListener('click', function() {
      autoMode = !autoMode;
      if (autoMode) {
        this.classList.add('active');
        updateAutoVertexFraction();
      } else {
        this.classList.remove('active');
      }
      tileDataMap.forEach(tileInfo => tileInfo._lastVertexFraction = undefined);
    });

    // Automatically set vertexFraction based on camera height
    function updateAutoVertexFraction() {
      if (!autoMode) return;
      let cameraHeight = 0;
      try {
        const globePos = cesiumViewer.camera.positionCartographic;
        cameraHeight = globePos ? globePos.height : 0;
      } catch (e) {}
      // Example auto formula: fraction decreases as camera height increases
      // 0.01 for 50km+, 0.05 for 10km+, 0.5 for 2km+, 1.0 for low heights
      let f = 1.0;
      if (cameraHeight > 50000) f = 0.01;
      else if (cameraHeight > 10000) f = 0.05;
      else if (cameraHeight > 2000) f = 0.5;
      else f = 1.0;
      vertexFraction = f;
      updateVertexFractionDisplay();
    }

    // Check if a point is valid (3 numeric coordinates)
    function isValidPoint(pt) {
      return Array.isArray(pt) && pt.length === 3 &&
        pt.every(v => typeof v === "number" && Number.isFinite(v));
    }
    // Check if a feature is valid (pair of valid points)
    function isValidFeature(feature) {
      return feature && Array.isArray(feature.points) && feature.points.length === 2 && isValidPoint(feature.points[0]) && isValidPoint(feature.points[1]);
    }

    // Group segments by polyline_id (or other group id), returns array of arrays of segments
    function groupSegmentsById(features) {
      const groups = {};
      for (const feature of features) {
        const id = feature.polylineId || feature.polyline_id || 0; // all in one group if no id
        if (!groups[id]) groups[id] = [];
        groups[id].push(feature.points);
      }
      return Object.values(groups);
    }

    // Efficiently join segments into chains (fast for large sets)
    function fastJoinSegments(segments) {
      const endpointMap = new Map();
      const pointKey = pt => pt.join(',');
      const used = new Array(segments.length).fill(false);
      segments.forEach((seg, i) => {
        for (const pt of seg) {
          const k = pointKey(pt);
          if (!endpointMap.has(k)) endpointMap.set(k, []);
          endpointMap.get(k).push(i);
        }
      });

      const polylines = [];
      for (let i = 0; i < segments.length; i++) {
        if (used[i]) continue;
        let line = [segments[i][0], segments[i][1]];
        used[i] = true;

        // Forward
        while (true) {
          const last = line[line.length - 1];
          const k = pointKey(last);
          const nextIdxs = endpointMap.get(k)?.filter(idx => !used[idx]);
          if (!nextIdxs || !nextIdxs.length) break;
          const nextIdx = nextIdxs[0];
          used[nextIdx] = true;
          if (pointKey(segments[nextIdx][0]) === k) {
            line.push(segments[nextIdx][1]);
          } else {
            line.push(segments[nextIdx][0]);
          }
        }
        // Backward
        while (true) {
          const first = line[0];
          const k = pointKey(first);
          const prevIdxs = endpointMap.get(k)?.filter(idx => !used[idx]);
          if (!prevIdxs || !prevIdxs.length) break;
          const prevIdx = prevIdxs[0];
          used[prevIdx] = true;
          if (pointKey(segments[prevIdx][0]) === k) {
            line.unshift(segments[prevIdx][1]);
          } else {
            line.unshift(segments[prevIdx][0]);
          }
        }
        polylines.push(line);
      }
      return polylines;
    }

    // Filter vertices by fraction (LOD)
    function filterVerticesByFraction(vertices, fraction) {
      if (fraction >= 0.999 || vertices.length < 3) return vertices;
      const numToKeep = Math.max(2, Math.round(vertices.length * fraction));
      if (numToKeep >= vertices.length) return vertices;
      const step = vertices.length / numToKeep;
      const result = [];
      for (let i = 0; i < vertices.length; i += step) {
        result.push(vertices[Math.floor(i)]);
      }
      // Always keep first and last vertices
      if (result[0] !== vertices[0]) result.unshift(vertices[0]);
      if (result[result.length-1] !== vertices[vertices.length-1]) result.push(vertices[vertices.length-1]);
      return result;
    }

    // Create Cesium PolylinePrimitive from vertices
    function createPolylinePrimitiveFromVertices(vertices, lineWidth) {
      const positions = vertices.map(pt => Cesium.Cartesian3.fromElements(...pt));
      return new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: new Cesium.PolylineGeometry({
            positions,
            width: lineWidth
          })
        }),
        appearance: new Cesium.PolylineColorAppearance(),
        asynchronous: false
      });
    }

    // === GLB parser that returns features with polyline_id ===
    async function extractLinesFromGlb(arrayBuffer) {
      try {
        const dv = new DataView(arrayBuffer);
        if (dv.getUint32(0, true) !== 0x46546C67) throw new Error("Not a GLB file");
        let offset = 12, json = null, bin = null;
        while (offset < dv.byteLength) {
          const chunkLength = dv.getUint32(offset, true);
          const chunkType = dv.getUint32(offset + 4, true);
          if (chunkType === 0x4E4F534A) {
            const jsonText = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset + 8, chunkLength));
            json = JSON.parse(jsonText);
          } else if (chunkType === 0x004E4942) {
            bin = new Uint8Array(arrayBuffer, offset + 8, chunkLength);
          }
          offset += 8 + chunkLength;
        }
        if (!json || !bin) throw new Error("GLB missing JSON or BIN chunk");

        function getBufferView(viewIdx) {
          const bv = json.bufferViews[viewIdx];
          return bin.subarray(bv.byteOffset || 0, (bv.byteOffset || 0) + bv.byteLength);
        }
        function getAccessor(accIdx) {
          const acc = json.accessors[accIdx];
          const bv = getBufferView(acc.bufferView);
          const TypedArray = (() => {
            switch (acc.componentType) {
              case 5120: return Int8Array;
              case 5121: return Uint8Array;
              case 5122: return Int16Array;
              case 5123: return Uint16Array;
              case 5125: return Uint32Array;
              case 5126: return Float32Array;
            }
          })();
          const numComponents = (() => {
            switch (acc.type) {
              case "SCALAR": return 1;
              case "VEC2": return 2;
              case "VEC3": return 3;
              case "VEC4": return 4;
              case "MAT4": return 16;
            }
          })();
          const array = new TypedArray(bv.buffer, bv.byteOffset + (acc.byteOffset || 0), acc.count * numComponents);
          return { array, count: acc.count, numComponents };
        }
        function getNodeMatrix(node) {
          if (node.matrix) return node.matrix;
          let m = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
          if (node.translation) {
            m[12] = node.translation[0];
            m[13] = node.translation[1];
            m[14] = node.translation[2];
          }
          return m;
        }
        function applyMatrixToPoint(xyz, m) {
          return [
            xyz[0] * m[0] + xyz[1] * m[4] + xyz[2] * m[8]  + m[12],
            xyz[0] * m[1] + xyz[1] * m[5] + xyz[2] * m[9]  + m[13],
            xyz[0] * m[2] + xyz[1] * m[6] + xyz[2] * m[10] + m[14]
          ];
        }

        // Collect features with polyline_id = meshIdx
        const features = [];
        if (!json.meshes) return features;
        for (let meshIdx = 0; meshIdx < json.meshes.length; meshIdx++) {
          const mesh = json.meshes[meshIdx];
          for (const prim of mesh.primitives) {
            if (prim.mode !== 1) continue; // Only lines
            const posAcc = getAccessor(prim.attributes.POSITION);
            let idxAcc = null;
            if (prim.indices !== undefined) idxAcc = getAccessor(prim.indices);
            let matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            const nodeIdx = json.nodes ? json.nodes.findIndex(n => n.mesh === meshIdx) : -1;
            if (nodeIdx >= 0) matrix = getNodeMatrix(json.nodes[nodeIdx]);
            if (idxAcc) {
              for (let i = 0; i < idxAcc.array.length; i += 2) {
                const ia = idxAcc.array[i], ib = idxAcc.array[i + 1];
                const a = [
                  posAcc.array[ia * 3 + 0],
                  posAcc.array[ia * 3 + 1],
                  posAcc.array[ia * 3 + 2]
                ];
                const b = [
                  posAcc.array[ib * 3 + 0],
                  posAcc.array[ib * 3 + 1],
                  posAcc.array[ib * 3 + 2]
                ];
                features.push({ points: [applyMatrixToPoint(a, matrix), applyMatrixToPoint(b, matrix)], polylineId: meshIdx });
              }
            } else {
              for (let i = 0; i < posAcc.count - 1; i += 2) {
                const a = [
                  posAcc.array[i * 3 + 0],
                  posAcc.array[i * 3 + 1],
                  posAcc.array[i * 3 + 2]
                ];
                const b = [
                  posAcc.array[(i + 1) * 3 + 0],
                  posAcc.array[(i + 1) * 3 + 1],
                  posAcc.array[(i + 1) * 3 + 2]
                ];
                features.push({ points: [applyMatrixToPoint(a, matrix), applyMatrixToPoint(b, matrix)], polylineId: meshIdx });
              }
            }
          }
        }
        return features.filter(isValidFeature);
      } catch(e) {
        logAction('GLB parse error: ' + e, 'error');
        return [];
      }
    }

    // Extract polyline features from a vector tile (GLB)
    async function extractPolylinesFromVectorTile(tile) {
      let glbUrl = null;
      if (tile.content && tile.content._resource && tile.content._resource._resource && tile.content._resource._resource.url) {
        glbUrl = tile.content._resource._resource.url;
      }
      if (!glbUrl && tile.content && tile.content.url) {
        glbUrl = tile.content.url;
      }
      if (!glbUrl) {
        logAction('No GLB url for tile', 'error');
        return [];
      }
      logAction('GLB url: ' + glbUrl, 'debug');
      if (!glbUrl.toLowerCase().endsWith('.glb')) {
        logAction('Skip non-GLB file: ' + glbUrl, 'debug');
        return [];
      }
      try {
        const response = await fetch(glbUrl);
        if (!response.ok) {
          logAction('GLB fetch error: HTTP ' + response.status, 'error');
          return [];
        }
        const arrayBuffer = await response.arrayBuffer();
        const features = await extractLinesFromGlb(arrayBuffer);
        return features;
      } catch (e) {
        logAction('GLB parse error: ' + e, 'error');
        return [];
      }
    }

    Cesium.Cesium3DTileset.fromUrl('aggr/tileset.json')
      .then(tileset => {
        tilesetInstance = tileset;
        cesiumViewer.scene.primitives.add(tileset);
        cesiumViewer.zoomTo(tileset);
        logAction('Tileset loaded', "system");
        tileset.tileLoad.addEventListener(async tile => {
          const features = await extractPolylinesFromVectorTile(tile);
          logAction(`Tile loaded, features found: ${features.length}`, "system");
          tileDataMap.set(tile, {
            features,
            primitive: null,
            _lastVertexFraction: undefined,
            _lastSimplified: undefined
          });
        });
      })
      .catch(err => {
        logAction('Failed to load tileset: ' + err, "error");
      });

    cesiumViewer.scene.postRender.addEventListener(() => {
      // FPS counter update
      fpsCounter++;
      const now = performance.now();
      if (now - lastFpsUpdate >= 1000) {
        fpsCounterValue.textContent = Math.round(fpsCounter * 1000 / (now - lastFpsUpdate));
        lastFpsUpdate = now;
        fpsCounter = 0;
      }
      // Update camera height display
      let cameraHeight = 0;
      try {
        const globePos = cesiumViewer.camera.positionCartographic;
        cameraHeight = globePos ? globePos.height : 0;
      } catch (e) {}
      cameraHeightVal.textContent = cameraHeight ? Math.round(cameraHeight) : '-';

      // Auto mode: update fraction if enabled
      if (autoMode) {
        updateAutoVertexFraction();
        tileDataMap.forEach(tileInfo => tileInfo._lastVertexFraction = undefined);
      }

      // Count and render polylines and vertices
      let vertexCount = 0, featureCount = 0, polylineCount = 0;
      if (!tilesetInstance || !tilesetInstance._selectedTiles) return;
      tilesetInstance._selectedTiles.forEach(tile => {
        const tileInfo = tileDataMap.get(tile);
        if (!tileInfo || !Array.isArray(tileInfo.features) || tileInfo.features.length === 0) return;
        // Group by polylineId
        const groups = groupSegmentsById(tileInfo.features);
        // For each polylineId, efficiently join segments into chains
        let allPrimitives = [];
        for (const segs of groups) {
          const polylines = fastJoinSegments(segs);
          for (const polyline of polylines) {
            const simplified = filterVerticesByFraction(polyline, vertexFraction);
            if (simplified.length < 2) continue;
            featureCount += 1;
            polylineCount += 1;
            vertexCount += simplified.length;
            allPrimitives.push(createPolylinePrimitiveFromVertices(simplified, 8.0));
          }
        }
        // Remove previous primitives
        if (tileInfo.primitive) {
          if (Array.isArray(tileInfo.primitive)) {
            tileInfo.primitive.forEach(p => cesiumViewer.scene.primitives.remove(p));
          } else {
            cesiumViewer.scene.primitives.remove(tileInfo.primitive);
          }
        }
        tileInfo.primitive = allPrimitives;
        // Add new primitives
        allPrimitives.forEach(p => cesiumViewer.scene.primitives.add(p));
      });
      vertexCounterValue.textContent = vertexCount;
      featureCounterValue.textContent = featureCount;
      polylineCounterValue.textContent = polylineCount;
    });
  </script>
</body>
</html>